# CmakeCpp

## 概要
cmakeを用いたC++のプロジェクト。

## 所有権と参照
あるクラスAが他のクラスBの所有権を持った上で、Bを参照する処理やクラスがインスタンスが存在するとする。
非同期処理が無ければ参照でもポインタでも大体問題無いが、非同期処理が絡むと「解放されているかもしれないインスタンス」への参照を扱う場面が出てくる。
素直にやるとAはBのshared_ptrを持ち、Bを参照する側はweak_ptrを持つ形になる。
しかしshared_ptrにすると安易にコピー出来てA以外が所有権を持つ状態が発生しやすい。
自身への参照を渡したい時はshared_from_thisが必要とかも面倒。
AがBのunique_ptrを明示的に持ったまま、他の処理はその参照を持つことで上手い事いかないかと試した。

## 結論
shared_ptrとweak_ptrを使うのが一番いい。というか確実な方法はこれしかない。
ポインタやunique_ptrの参照を持つことで解放されたかどうか確認できそうな気がしたが、仮にヌルチェックができてもその後の操作中に解放される可能性がある。
また、ポインタの参照を持つと、そのポインタ自体が解放される可能性もある。
これらの問題を避けるにはshared_ptrとweak_ptrを使うのが最も安全で確実な方法である。

## ClaudeCodeからの補足事項

### 各Launchメソッドの問題点
1. **Launch1 (値メンバ b_ の参照キャプチャ)**
   - Holderが破棄されると、b_もスタック上で解放される
   - detachされたスレッドがb_にアクセスすると未定義動作（ダングリング参照）
   - 仮にメモリが残っていても、データ競合の可能性がある

2. **Launch2 (生ポインタ pb_ のコピーキャプチャ)**
   - デストラクタで`delete pb_`が実行されるため、スレッド実行時には解放済み
   - ヌルチェックは通らない（ポインタ自体はコピーされた値を保持）
   - 解放済みメモリへのアクセスは未定義動作

3. **Launch2b (生ポインタ pb_ の参照キャプチャ)**
   - pb_自体（メンバ変数）への参照を保持
   - Holder破棄時にpb_メンバも解放されるため、より危険
   - ヌルチェックすら不定（pb_メンバ自体が存在しない）

4. **Launch3 (unique_ptr upb_ の参照キャプチャ)**
   - unique_ptrの参照を保持しても、ヌルチェックは機能する
   - しかし、チェック後からアクセスまでの間に解放される可能性がある（TOCTOU問題）
   - unique_ptrは単一所有権を前提としており、非同期処理には不適

5. **Launch4 (shared_ptr spb_ から weak_ptr を作成)**
   - weak_ptr::lock()で安全に有効性を確認できる
   - lockが成功すれば、そのスコープ内では解放されない保証がある
   - 唯一安全な実装パターン

### std::thread::detach() の注意点
このコードでは`detach()`を使用しているが、実用上は以下の点に注意：
- detachしたスレッドはプログラム終了時に強制終了される可能性がある
- キャプチャしたオブジェクトのライフタイム管理が困難
- 通常は`join()`を使用してスレッドの完了を待つべき
- detachを使う場合は、スレッドがアクセスする全てのオブジェクトをshared_ptr/weak_ptrで管理する

### std::enable_shared_from_this の活用
自身への参照を渡したい場合は`std::enable_shared_from_this`を継承することで`shared_from_this()`が使える：
```cpp
class MyClass : public std::enable_shared_from_this<MyClass> {
    void StartAsync() {
        std::thread([self = shared_from_this()] {
            // selfを安全に使える
        }).detach();
    }
};
```
ただし、shared_ptrで管理されている必要がある。

### データ競合への注意
複数スレッドから同じオブジェクトにアクセスする場合、データ競合に注意が必要：
- Launch1では`b_.SetNum(11)`が他のスレッドと競合する可能性
- 読み書きが発生する場合はmutexなどの同期機構が必要
- shared_ptr/weak_ptrはポインタ自体の操作は安全だが、指す先のオブジェクトへのアクセスは保護しない
